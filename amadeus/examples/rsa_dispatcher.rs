// RSA Encrypted Dispatcher Example
// ËøêË°å: cargo run --example rsa_dispatcher

use amadeus::App;
use amadeus::plugins::iceoryx2_dispatcher::Iceoryx2DispatcherPlugin;
use amadeus::plugins::message_example::MessageExamplePlugin;
use amadeus::core::messaging::message::Message;
use amadeus::plugin::Plugin;
use amadeus::core::messaging::message_context::MessageContext;
use amadeus::core::messaging::distribution_center::DistributionCenter;
use amadeus::plugin::PluginMetadata;
use anyhow::Result;
use std::fs;
use std::sync::Arc;
use tokio::sync::mpsc;
use std::pin::Pin;

// Simple plugin that sends messages periodically to verify encryption
struct PeriodicSenderPlugin {
    metadata: PluginMetadata,
}

impl PeriodicSenderPlugin {
    fn new() -> Self {
        Self {
            metadata: PluginMetadata::new("periodic-sender", "Sends periodic messages", "0.1.0"),
        }
    }
}

impl Plugin for PeriodicSenderPlugin {
    fn id(&self) -> &str { &self.metadata.name }
    fn metadata(&self) -> &PluginMetadata { &self.metadata }

    fn setup_messaging(
        &mut self,
        dc: &DistributionCenter,
        tx: mpsc::Sender<Message>,
    ) -> Pin<Box<dyn std::future::Future<Output = Result<Option<Arc<MessageContext>>>> + Send>> {
        let plugin_name = self.metadata.name.clone();
        let plugin_uid = self.metadata.uid.clone();
        let dc = Arc::new(dc.clone());

        Box::pin(async move {
            let ctx = Arc::new(MessageContext::new(dc, plugin_name, plugin_uid, tx));
            let ctx_clone = ctx.clone();

            tokio::spawn(async move {
                let mut interval = tokio::time::interval(std::time::Duration::from_secs(2));
                let mut count = 0;
                loop {
                    interval.tick().await;
                    count += 1;
                    
                    let msg = Message::new(
                        "demo.periodic", 
                        serde_json::json!({
                            "count": count,
                            "secret_info": "This message should be encrypted when leaving the system!",
                            "timestamp": std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs()
                        })
                    );
                    
                    if let Err(e) = ctx_clone.send(msg).await {
                        tracing::error!("Failed to send periodic message: {}", e);
                    } else {
                        tracing::info!("üì§ Sent periodic message #{}", count);
                    }
                }
            });

            Ok(Some(ctx))
        })
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt::init();
    tracing::info!("=== Amadeus RSA Encrypted Dispatcher ===");

    // Try to find the public key generated by the Python script
    // Check multiple locations
    let possible_paths = [
        "examples/iceoryx2/public_key.pem",
        "amadeus/examples/iceoryx2/public_key.pem",
        "public_key.pem"
    ];

    let mut key_content = None;
    let mut key_path_used = "";

    for path in possible_paths.iter() {
        if let Ok(content) = fs::read_to_string(path) {
            key_content = Some(content);
            key_path_used = path;
            break;
        }
    }

    let dispatcher = if let Some(key_pem) = key_content {
        tracing::info!("üîë Loaded Public Key from {}", key_path_used);
        Iceoryx2DispatcherPlugin::new("amadeus_rsa")
            .with_public_key(key_pem)
    } else {
        tracing::warn!("‚ö†Ô∏è  Public Key not found. Running without encryption.");
        tracing::info!("   Please run 'python3 examples/iceoryx2/rsa_test.py' first to generate keys.");
        Iceoryx2DispatcherPlugin::new("amadeus_rsa")
    };

    let app = App::with_plugins(vec![
        Box::new(dispatcher),
        Box::new(MessageExamplePlugin::new()),
        Box::new(PeriodicSenderPlugin::new()),
    ])
    .with_messaging()
    .show_metadata(true);

    app.run_async().await?;

    Ok(())
}

